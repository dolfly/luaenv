<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="default.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
		<ul>
				<li><a href="coroutine.html">coroutine</a></li>
				<li><a href="debug.html">debug</a></li>
				<li><a href="global.html">global</a></li>
				<li><a href="io.html">io</a></li>
				<li><a href="math.html">math</a></li>
				<li><a href="os.html">os</a></li>
				<li><a href="package.html">package</a></li>
				<li>string</li>
				<li><a href="table.html">table</a></li>
				<li><a href="index.html">index</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>string</code></h1>
    String Manipulation.
   <br/>This library provides generic functions for string manipulation,
 such as finding and extracting substrings, and pattern matching.
 When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). 
 Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string.
 Thus, the last character is at position -1, and so on.</p>

<p> The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style.
 For instance, string.byte(s, i) can be written as s:byte(i).</p>

<p> The string library assumes one-byte character encodings.
			<a id="string" />
			<h2>Type <code>string</code></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.sub">string.sub(s, i, j)</a></td>
		<td class="summary"> Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
 <code>j</code>; <code>i</code> and <code>j</code> can be negative.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.upper">string.upper(s)</a></td>
		<td class="summary"> Receives a string and returns a copy of this string with all lowercase
 letters changed to uppercase.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.char">string.char()</a></td>
		<td class="summary"> Receives zero or more integers.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.rep">string.rep(s, n)</a></td>
		<td class="summary"> Returns a string that is the concatenation of <code>n</code> copies of the string
 <code>s</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.find">string.find(s, pattern, init, plain)</a></td>
		<td class="summary"> Looks for the first match of <code>pattern</code> in the string <code>s</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.match">string.match(s, pattern, init)</a></td>
		<td class="summary"> Looks for the first <em>match</em> of <code>pattern</code> in the string <code>s</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.gmatch">string.gmatch(s, pattern)</a></td>
		<td class="summary"> Returns an iterator function that, each time it is called, returns the
 next captures from <code>pattern</code> over string <code>s</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.dump">string.dump()</a></td>
		<td class="summary"> Returns a string containing a binary representation of the given
 function, so that a later <code>loadstring</code> on this string returns a copy of
 the function.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.gsub">string.gsub(s, pattern, repl, n)</a></td>
		<td class="summary"> Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given)
 occurrences of the <code>pattern</code> have been replaced by a replacement string
 specified by <code>repl</code>, which can be a string, a table, or a function.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.reverse">string.reverse(s)</a></td>
		<td class="summary"> Returns a string that is the string <code>s</code> reversed.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.byte">string.byte(s, i, j)</a></td>
		<td class="summary"> Returns the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,
 ..., <code>s[j]</code>.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.format">string.format(formatstring)</a></td>
		<td class="summary"> Returns a formatted version of its variable number of arguments following
 the description given in its first argument (which must be a string).</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.len">string.len(s)</a></td>
		<td class="summary"> Receives a string and returns its length.</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="#string.lower">string.lower(s)</a></td>
		<td class="summary"> Receives a string and returns a copy of this string with all uppercase
 letters changed to lowercase.</td>
		</tr>
	</table>

			<h2>Type <code>string</code></h2>
			<a id ="anchor(_recordtypedef)"></a>
	<h3>Field(s)</h3>
		<a id="string.sub" />
<dl class="function">
<dt>
<strong>string.sub(s, i, j)</strong>
</dt>
<dd>
	 Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
 <code>j</code>; <code>i</code> and <code>j</code> can be negative.
	If <code>j</code> is absent, then it is assumed to
 be equal to -1 (which is the same as the string length). In particular,
 the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code> with length <code>j</code>, and
 <code>string.sub(s, -i)</code> returns a suffix of <code>s</code> with length <code>i</code>.
		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				i  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				j  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.upper" />
<dl class="function">
<dt>
<strong>string.upper(s)</strong>
</dt>
<dd>
	 Receives a string and returns a copy of this string with all lowercase
 letters changed to uppercase.
	All other characters are left unchanged. The
 definition of what a lowercase letter is depends on the current locale.
		<h3>Parameter</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.char" />
<dl class="function">
<dt>
<strong>string.char()</strong>
</dt>
<dd>
	 Receives zero or more integers.
	Returns a string with length equal to
 the number of arguments, in which each character has the internal numerical
 code equal to its corresponding argument.
 Note that numerical codes are not necessarily portable across platforms.
</dd>
</dl>
		<a id="string.rep" />
<dl class="function">
<dt>
<strong>string.rep(s, n)</strong>
</dt>
<dd>
	 Returns a string that is the concatenation of <code>n</code> copies of the string
 <code>s</code>.
	


		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				n  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.find" />
<dl class="function">
<dt>
<strong>string.find(s, pattern, init, plain)</strong>
</dt>
<dd>
	 Looks for the first match of <code>pattern</code> in the string <code>s</code>.
	If it finds a
 match, then <code>find</code> returns the indices of <code>s</code> where this occurrence starts
 and ends; otherwise, it returns nil. A third, optional numerical argument
 <code>init</code> specifies where to start the search; its default value is 1 and
 can be negative. A value of true as a fourth, optional argument <code>plain</code>
 turns off the pattern matching facilities, so the function does a plain
 "find substring" operation, with no characters in <code>pattern</code> being considered
 "magic". Note that if <code>plain</code> is given, then <code>init</code> must be given as well.
 If the pattern has captures, then in a successful match the captured values
 are also returned, after the two indices.
		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				pattern  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				init  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				plain  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.match" />
<dl class="function">
<dt>
<strong>string.match(s, pattern, init)</strong>
</dt>
<dd>
	 Looks for the first <em>match</em> of <code>pattern</code> in the string <code>s</code>.
	If it
 finds one, then <code>match</code> returns the captures from the pattern; otherwise
 it returns nil. If <code>pattern</code> specifies no captures, then the whole match
 is returned. A third, optional numerical argument <code>init</code> specifies where
 to start the search; its default value is 1 and can be negative.
		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				pattern  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				init  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.gmatch" />
<dl class="function">
<dt>
<strong>string.gmatch(s, pattern)</strong>
</dt>
<dd>
	 Returns an iterator function that, each time it is called, returns the
 next captures from <code>pattern</code> over string <code>s</code>.
	If <code>pattern</code> specifies no
 captures, then the whole match is produced in each call.
 As an example, the following loop</p>

<pre><code> s = "hello world from Lua"
 for w in string.gmatch(s, "%a+") do
   print(w)
 end
</code></pre>

<p> will iterate over all the words from string <code>s</code>, printing one per line. The
 next example collects all pairs <code>key=value</code> from the given string into
 a table:</p>

<pre><code> t = {}
 s = "from=world, to=Lua"
 for k, v in string.gmatch(s, "(%w+)=(%w+)") do
   t[k] = v
 end
</code></pre>

<p> For this function, a '<code>^</code>' at the start of a pattern does not work as an
 anchor, as this would prevent the iteration.
		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				pattern  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.dump" />
<dl class="function">
<dt>
<strong>string.dump()</strong>
</dt>
<dd>
	 Returns a string containing a binary representation of the given
 function, so that a later <code>loadstring</code> on this string returns a copy of
 the function.
	<code>function</code> must be a Lua function without upvalues.
</dd>
</dl>
		<a id="string.gsub" />
<dl class="function">
<dt>
<strong>string.gsub(s, pattern, repl, n)</strong>
</dt>
<dd>
	 Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given)
 occurrences of the <code>pattern</code> have been replaced by a replacement string
 specified by <code>repl</code>, which can be a string, a table, or a function.
	
<p><code>gsub</code>
 also returns, as its second value, the total number of matches that occurred.</p>

<p> If <code>repl</code> is a string, then its value is used for replacement. The character
 <code>%</code> works as an escape character: any sequence in <code>repl</code> of the form <code>%n</code>,
 with <em>n</em> between 1 and 9, stands for the value of the <em>n</em>-th captured
 substring (see below). The sequence <code>%0</code> stands for the whole match. The
 sequence <code>%%</code> stands for a single <code>%</code>.</p>

<p> If <code>repl</code> is a table, then the table is queried for every match, using
 the first capture as the key; if the pattern specifies no captures, then
 the whole match is used as the key.</p>

<p> If <code>repl</code> is a function, then this function is called every time a match
 occurs, with all captured substrings passed as arguments, in order; if
 the pattern specifies no captures, then the whole match is passed as a
 sole argument.</p>

<p> If the value returned by the table query or by the function call is a
 string or a number, then it is used as the replacement string; otherwise,
 if it is false or nil, then there is no replacement (that is, the original
 match is kept in the string).</p>

<p> Here are some examples:</p>
<pre><code> x = string.gsub("hello world", "(%w+)", "%1 %1")
 --&gt; x="hello hello world world"
 x = string.gsub("hello world", "%w+", "%0 %0", 1)
 --&gt; x="hello hello world"
 x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
 --&gt; x="world hello Lua from"
 x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
 --&gt; x="home = /home/roberto, user = roberto"
 x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
       return loadstring(s)()
     end)
 --&gt; x="4+5 = 9"
 local t = {name="lua", version="5.1"}
 x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
 --&gt; x="lua-5.1.tar.gz"
</code></pre>

		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				pattern  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				repl  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				n  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.reverse" />
<dl class="function">
<dt>
<strong>string.reverse(s)</strong>
</dt>
<dd>
	 Returns a string that is the string <code>s</code> reversed.
	


		<h3>Parameter</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.byte" />
<dl class="function">
<dt>
<strong>string.byte(s, i, j)</strong>
</dt>
<dd>
	 Returns the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,
 ..., <code>s[j]</code>.
	The default value for <code>i</code> is 1; the default value for <code>j</code>
 is <code>i</code>.
 Note that numerical codes are not necessarily portable across platforms.
		<h3>Parameters</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				i  
				</em></code>:
					


				</li>
				<li>
				<code><em>
				j  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.format" />
<dl class="function">
<dt>
<strong>string.format(formatstring)</strong>
</dt>
<dd>
	 Returns a formatted version of its variable number of arguments following
 the description given in its first argument (which must be a string).
	The
 format string follows the same rules as the <code>printf</code> family of standard C
 functions. The only differences are that the options/modifiers <code>*</code>, <code>l</code>,
 <code>L</code>, <code>n</code>, <code>p</code>, and <code>h</code> are not supported and that there is an extra option,
 <code>q</code>. The <code>q</code> option formats a string in a form suitable to be safely read
 back by the Lua interpreter: the string is written between double quotes,
 and all double quotes, newlines, embedded zeros, and backslashes in the
 string are correctly escaped when written. For instance, the call</p>

<pre><code> string.format('%q', 'a string with "quotes" and \n new line')
</code></pre>

<p> will produce the string:</p>

<pre><code> "a string with \"quotes\" and \
     new line"
</code></pre>

<p> The options <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and
 <code>x</code> all expect a number as argument, whereas <code>q</code> and <code>s</code> expect a string.
 This function does not accept string values containing embedded zeros,
 except as arguments to the <code>q</code> option.
		<h3>Parameter</h3>
		<ul>
				<li>
				<code><em>
				formatstring  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.len" />
<dl class="function">
<dt>
<strong>string.len(s)</strong>
</dt>
<dd>
	 Receives a string and returns its length.
	The empty string <code>""</code> has
 length 0. Embedded zeros are counted, so <code>"a\000bc\000"</code> has length 5.
		<h3>Parameter</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>
		<a id="string.lower" />
<dl class="function">
<dt>
<strong>string.lower(s)</strong>
</dt>
<dd>
	 Receives a string and returns a copy of this string with all uppercase
 letters changed to lowercase.
	All other characters are left unchanged. The
 definition of what an uppercase letter is depends on the current locale.
		<h3>Parameter</h3>
		<ul>
				<li>
				<code><em>
				s  
				</em></code>:
					


				</li>
		</ul>
</dd>
</dl>

</div>

</div>
</body>
</html>
